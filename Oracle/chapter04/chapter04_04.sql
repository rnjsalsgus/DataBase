-- chatper04-04

-- 데이터베이스의 물리적 저장
-- 실제 데이터가 저장 되는 곳은 보조기억장치
-- 보조 기억 장치는 일반적으로 하드디스크,ssd,usb메모리 등이 있다.
-- 하드디스크에 데이터를 저장하고 읽어 올 때는 기본적인 속도 문제 발생

-- 인덱스와 B-tree
-- 인덱스(Index), 색인
-- 자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터구조

-- B_tree
-- 각 노드는 키값과 포인터를 가진다
-- 키 값은 오름차순으로 저장되어 있으며 키 값 좌우에 있는 포인터는
-- 각각 키 값보다 작은 값과 큰 값을 가진 다른 노드를 가리킨다
-- 키 값을 비교하여 다음 단계의 노드를 쉽게 찾을 수 있다.

-- 데이터베이스 sql문 처리 속도를 올리는 것을 데이터베이스 튜닝
-- 데이터를 나누어서 데이터 단위를 작게 만드는 것이 가장 좋은 튜닝
-- 그전에 데이터가 조금 많아서 속도를 올리기 위해 인덱스를 생성할 수 있다.

-- 인덱스의 생성
-- 인덱스는 데이터 검색을 빨리 하기 위해 사용
-- 인덱스를 생성했다고 해서 데이터 검색이 무조건 빨라 지는 것은 아니다.
-- 데이터의 양이 적거나 데이터 값의 종류가 적어 선택도가 좁으면
-- 인덱스가 없는 것이 더 빠를 수 있다.
-- 선택도란, 서로 다른 값의 개수
-- 예) 100개의 행을 가진 테이블 값이 남,여 두가지라면 선택도가 높다고 할 수 있다.
-- 따라서 의미 없이 인덱스를 생성하면 검색이 더 느려질 수 있고 저장공간이 낭비
-- 인덱스 생성에 앞서 고려사항을 충분히 살펴 봐야 한다.

-- 고려사항
-- 인덱스는 where절과 join에 자주 사용되는 속성이어야 한다.
-- 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다.
-- (테이블 4~5개 정도 권장)
-- 속성이 가공되는 경우 사용하지 않는다.
-- 속성의 선택도 낮을 때 유리하다(속성의 모든 값이 다른 경우)

-- create [reverse][unique] index [인덱스이름]
-- on 테이블이름(칼럼[asc|desc][{,칼럼[asc|desc]}...])[;]
-- reverse는 역순으로 인덱스 생성
-- unique는 테이블의 속성값에 대하여 중복이 없는 유일한 인덱스를 생성

-- book 테이블의 bookname 열의 대상으로 인덱스 ix_book을 생성
create index ix_book on book(bookname);

-- book 테이블의 publisher,price열을 대상으로 인덱스 ix_book2를 생성
create index ix_book2 on book(publisher,price);

select *from book
where publisher like '대한미디어' and price<=30000;

-- f10키를 누르면 객체 탐색기를 열 수 있음.
-- 생성된 인덱스를 활용하여 sql문을 처리하는지 확인할 수 있다.

-- 인덱스의 재구성과 삭제
-- B-tree 인덱스는 데이터의 수정,삭제,삽입이 잦으면 노드의 갱신이 주기적으로
-- 일어나 단편화 현상이 나타난다.
-- 단편화란 삭제된 레코드의 인덱스의 값 자리가 비게되는 상태를 말한다.
-- 검색 시 성능 저하로 이어진다.
-- 인덱스를 다시 생성해 줘야 한다.

-- 인덱스 재구성 문법
-- alter [reverse|unique] index 인덱스이름
-- [on {only} 테이블이름 (칼럼이름[{, 칼럼이름}...] rebulid[;]

-- 인덱스 ix_book을 재구성
alter index ix_book rebuild;

-- 하나의 테이블에 인덱스가 많으면 데이터베이스 성능에 좋지 않다.
-- 인덱스 삭제
-- drop index 인덱스이름[;]

-- 인덱스 ix_book 삭제
drop index ix_book;





























